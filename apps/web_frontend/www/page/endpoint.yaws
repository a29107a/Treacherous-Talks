<erl>
%%%-------------------------------------------------------------------
%%% @copyright
%%% COPYRIGHT
%%% @end
%%%-------------------------------------------------------------------
%%% @author Sukumar Yethadka <sbhat7@gmail.com>
%%%
%%% @doc Websocket endpoint
%%%
%%% @since : 25 Oct 2011 by Bermuda Triangle
%%% @end
%%%-------------------------------------------------------------------

%%-------------------------------------------------------------------
%% Record defines the return value to the web socket
%%
%% event: Name of the event used by js callbacks to make changes to web page
%% event_data: Encoded data that may be relevant for the event
%% page: The page that has to be loaded on the client
%% message_type: Type of message to be displayed (optional)
%%               success, error, warning, info
%% message_value: Data to be displayed as the message
%%-------------------------------------------------------------------
-record(ret, {event="",
              event_data="",
              page="",
              message_type="",
              message_value=""}).

-include_lib("datatypes/include/push_receiver.hrl").
-include_lib("datatypes/include/push_event.hrl").
%%-------------------------------------------------------------------
%% @doc
%% Yaws function that gets called when an endpoint is requested.
%% The function creates a process for every websocket connection.
%% @end
%%-------------------------------------------------------------------
out(A) ->
    io:format("Spawning websocket owner~n",[]),
    WebSocketOwner = spawn(fun() -> websocket_owner() end),
    {websocket, WebSocketOwner, true}.


%%-------------------------------------------------------------------
%% @doc
%% Websocket owner - function to start the websocket server
%% @end
%%-------------------------------------------------------------------
websocket_owner() ->
    receive
    {ok, WebSocket, ProtocolVersion} ->
        socket_server(WebSocket, ProtocolVersion);
    _ -> ok
    end.


%%-------------------------------------------------------------------
%% @doc
%% Websocket server
%% @end
%%-------------------------------------------------------------------
socket_server(WebSocket, ProtocolVersion) ->
    receive
        {tcp, WebSocket, DataFrame} ->
            Data = yaws_api:websocket_unframe_data(ProtocolVersion, DataFrame),
            io:format("Got data from Websocket: ~p~n", [json_decode(Data)]),
            ParsedCmd = case web_parser:parse(json_decode(Data)) of
                            {login, {ok, User}} ->
                                PushReceiver = #push_receiver{
                                  pid = self(),
                                  args = [WebSocket, ProtocolVersion],
                                  type = web},
                                {login, {ok, {User, PushReceiver}}};
                            Other ->
                                Other
                        end,
            controller:handle_action(ParsedCmd,
                                     {fun reply/3,
                                     [WebSocket, ProtocolVersion]}),
            socket_server(WebSocket, ProtocolVersion);
        {tcp_closed, WebSocket} ->
            io:format("Websocket closed. Terminating socket_server...~n");
        {push, [Websocket, ProtocolVersion], Event} = P ->
            case Event of
                #push_event{type = Type, data = Msg} ->
                    reply ([WebSocket, ProtocolVersion], Type, Msg);
                _ ->
                    io:format("received illegal push: ~p~n", [P]),
                    ok
            end,
            socket_server(WebSocket, ProtocolVersion);
        Any ->
            io:format("socket_server received unhandled msg:~p~n", [Any]),
            socket_server(WebSocket, ProtocolVersion)
    end.

%%-------------------------------------------------------------------
%% @doc
%% Callback function that gets called by controller
%% @end
%%-------------------------------------------------------------------
reply([WebSocket, ProtocolVersion], Result, Data) ->
    Reply = get_reply(Result, Data, fe_messages:get(Result, Data)),
    yaws_api:websocket_send(WebSocket, ProtocolVersion, Reply).

%%-------------------------------------------------------------------
%% Compose replies based on data returned from backend
%%-------------------------------------------------------------------
get_reply({Cmd, Status}, Data, Msg) ->
    Event = atom_to_list(Cmd) ++ "_" ++ atom_to_list(Status),
    Reply = get_ret({Cmd, Status}, #ret{event=Event, message_value=Msg}, Data),
    json_encode(ret_to_proplist(Reply));
get_reply (CmdWithoutStatus, Data, Msg) ->
    get_reply ({CmdWithoutStatus, ok}, Data, Msg);
get_reply(unknown_command, Data, Msg) ->
    io:format("Unknown command ~p~n", [Data]),
    json_encode("").


%%-------------------------------------------------------------------
%% Functions that handle return data
%%-------------------------------------------------------------------
%% @doc
%% Format for returning messages to the client
%% Returns the updated ret record
%% @end
%%-------------------------------------------------------------------
%% Update message type to success
msg_success(Ret=#ret{}) ->
    Ret#ret{message_type="success"}.

%% Update message type to error
msg_error(Ret=#ret{}) ->
    Ret#ret{message_type="error"}.

msg_ret (Ret=#ret{}, MsgType) ->
    Ret#ret{message_type = MsgType}.

msg_invisible (Ret=#ret{}) ->
    Ret#ret{message_type="invisible"}.

get_ret ({user_msg, success}, Ret, _Data) ->
    msg_ret (Ret, "send_off_game_msg");
get_ret ({off_game_msg, ok}, Ret, Data) ->
    get_ret (off_game_msg, Ret, Data);
get_ret (off_game_msg, Ret = #ret{}, _Data) ->
    msg_ret (Ret, "recv_off_game_msg");

get_ret ({game_msg, success}, Ret, _Data) ->
    msg_ret (Ret, "send_in_game_msg");
get_ret ({game_msg, invalid_data}, Ret, _Data) ->
    msg_error(Ret);
get_ret ({in_game_msg, ok}, Ret, Data) ->
    get_ret (in_game_msg, Ret, Data);
get_ret (in_game_msg, Ret = #ret{}, _Data) ->
    msg_ret (Ret, "recv_in_game_msg");

get_ret({register, success}, Ret=#ret{}, _Data) ->
    msg_success(Ret#ret{page="home"});
get_ret({register, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({login, success}, Ret=#ret{}, Session) ->
    Data = [{"session_id", Session}],
    EventData = json2:obj_from_list(Data),
    msg_success(Ret#ret{event_data = EventData,
                        page="dashboard"});
get_ret({login, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({get_session_user, success}, Ret=#ret{}, User) ->
    RequiredFields = [nick, email, name],
    Data = data_format:rec_to_plist(User, {string, RequiredFields}),
    EventData = json2:obj_from_list(Data),
    msg_success(Ret#ret{event_data = EventData,
                        page="dashboard"});
get_ret({get_session_user, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);
get_ret({get_session_user, invalid_session}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({update_user, success}, Ret=#ret{}, User) ->
    RequiredFields = [nick, email, name],
    Data = data_format:rec_to_plist(User, {string, RequiredFields}),
    EventData = json2:obj_from_list(Data),
    msg_success(Ret#ret{event_data = EventData,
                        page="dashboard"});
get_ret({update_user, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({get_game, success}, Ret=#ret{}, Game) ->
    RequiredFields = [id, creator_id, name, description, password,
                      press, order_phase, retreat_phase, build_phase,
                      waiting_time, num_players, result],
    Data = data_format:rec_to_plist(Game, {string, RequiredFields}),
    EventData = json2:obj_from_list(Data),
    msg_success(Ret#ret{event_data = EventData});
get_ret({get_game, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({reconfig_game, success}, Ret=#ret{}, _Data) ->
    msg_success(Ret#ret{page="dashboard"});
get_ret({reconfig_game, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({create_game, success}, Ret=#ret{}, _Data) ->
    msg_success(Ret#ret{page="dashboard"});
get_ret({create_game, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({join_game, success}, Ret=#ret{}, _Data) ->
    msg_success(Ret#ret{page="dashboard"});
get_ret({join_game, error}, Ret=#ret{}, _Data) ->
    msg_error(Ret#ret{page="dashboard"});
get_ret({join_game, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret#ret{page="dashboard"});

get_ret({game_overview, success}, Ret=#ret{}, GOv) ->
    case data_format:game_overview_to_text(GOv) of
        {_, finished, FinishedData} ->
            finished_overview_ret(FinishedData, Ret);
        {GameId, _Status, Data} ->
            game_overview_ret(GameId, Data, Ret);
        _ -> msg_error(Ret)
    end;
get_ret({game_overview, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({game_order, success}, Ret=#ret{}, _Data) ->
    msg_success(Ret);
get_ret({game_order, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({get_db_stats, success}, Ret=#ret{}, JsonDbStats) ->
    Data = [{"db_stats", JsonDbStats}],
    EventData = json2:obj_from_list(Data),
    msg_success(Ret#ret{event_data = EventData});
get_ret({get_db_stats, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({games_current, success}, Ret=#ret{}, Games) ->
    RequiredFields = [id, name, status, description,
                      press, order_phase, retreat_phase, build_phase,
                      waiting_time, num_players],
    EventData = lists:map(fun(Game) ->
                json2:obj_from_list(data_format:rec_to_plist(Game,
                                    {string, RequiredFields}))
                          end, Games),
    msg_success(Ret#ret{event_data = EventData,
                        page = "games_current"});
get_ret({games_current, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({game_search, success}, Ret=#ret{}, Games) ->
    RequiredFields = [id, name, status, description,
                      press, order_phase, retreat_phase, build_phase,
                      waiting_time, num_players],
    EventData = lists:map(fun(Game) ->
        json2:obj_from_list(data_format:rec_to_plist(Game,
                                                     {string, RequiredFields}))
        end, Games),
    msg_success(Ret#ret{event_data = EventData});
get_ret({game_search, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret).


%% Convert data from websocket (JSON) to erlang terms
json_decode(Data) ->
    json2:decode_string(binary_to_list(Data)).

%% Convert erlang terms to JSON
json_encode(Data) ->
    list_to_binary(json2:encode(json2:obj_from_list(Data))).

%% Converts ret record to proplist
ret_to_proplist(Ret) ->
    RecordInfo = [atom_to_list(Field) || Field <- record_info(fields, ret)],
    lists:zip(RecordInfo, tl(tuple_to_list(Ret))).

game_overview_ret(Id, {Info, Country, Game, Provinces, Units, Orders}, Ret=#ret{}) ->
    OrdersString = lists:flatten(io_lib:format("~p", [Orders])),
    Data = [{"game_status", "ongoing"},
            {"game_id", integer_to_list(Id)},
            {"country", atom_to_list(Country)},
            {"game_info", lists:flatten(Info)},
            {"game", lists:flatten(Game)},
            {"provinces", lists:flatten(Provinces)},
            {"units", lists:flatten(Units)},
            {"orders", OrdersString}],
    EventData = json2:obj_from_list(Data),
    msg_success(Ret#ret{event_data = EventData,
                        page="game"}).

finished_overview_ret({Info, PlayerInfo, Game, FinalMap}, Ret=#ret{}) ->
    Data = [{"game_status", "finished"},
            {"game_info", lists:flatten(Info)},
            {"game", lists:flatten(Game)},
            {"players", lists:flatten(PlayerInfo)},
            {"map", lists:flatten(FinalMap)}],
    EventData = json2:obj_from_list(Data),
    msg_success(Ret#ret{event_data = EventData,
                        page="game_finished"}).

</erl>
