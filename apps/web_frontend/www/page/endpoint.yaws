<erl>
%%%-------------------------------------------------------------------
%%% @copyright
%%% COPYRIGHT
%%% @end
%%%-------------------------------------------------------------------
%%% @author Sukumar Yethadka <sbhat7@gmail.com>
%%%
%%% @doc Websocket endpoint
%%%
%%% @since : 25 Oct 2011 by Bermuda Triangle
%%% @end
%%%-------------------------------------------------------------------

%%-------------------------------------------------------------------
%% Record defines the return value to the web socket
%%
%% event: Name of the event used by js callbacks to make changes to web page
%% event_data: Encoded data that may be relevant for the event
%% page: The page that has to be loaded on the client
%% message_type: Type of message to be displayed (optional)
%%               success, error, warning, info
%% message_value: Data to be displayed as the message
%%-------------------------------------------------------------------
-record(ret, {event="",
              event_data="",
              page="",
              message_type="",
              message_value=""}).

-include_lib("datatypes/include/push_receiver.hrl").
%%-------------------------------------------------------------------
%% @doc
%% Yaws function that gets called when an endpoint is requested.
%% The function creates a process for every websocket connection.
%% @end
%%-------------------------------------------------------------------
out(A) ->
    io:format("Spawning websocket owner~n",[]),
    WebSocketOwner = spawn(fun() -> websocket_owner() end),
    {websocket, WebSocketOwner, true}.


%%-------------------------------------------------------------------
%% @doc
%% Websocket owner - function to start the websocket server
%% @end
%%-------------------------------------------------------------------
websocket_owner() ->
    receive
    {ok, WebSocket, ProtocolVersion} ->
        socket_server(WebSocket, ProtocolVersion);
    _ -> ok
    end.


%%-------------------------------------------------------------------
%% @doc
%% Websocket server
%% @end
%%-------------------------------------------------------------------
socket_server(WebSocket, ProtocolVersion) ->
    receive
        {tcp, WebSocket, DataFrame} ->
            Data = yaws_api:websocket_unframe_data(ProtocolVersion, DataFrame),
            io:format("Got data from Websocket: ~p~n", [Data]),
            ParsedCmd = case web_parser:parse(json_decode(Data)) of
                            {login, {ok, User}} ->
                                PushReceiver = #push_receiver{
                                  pid = self(),
                                  args = [WebSocket, ProtocolVersion]},
                                {login, {ok, {User, PushReceiver}}};
                            Other ->
                                Other
                        end,
            io:format("Parsed command: ~p~n", [ParsedCmd]),
            controller:handle_action(ParsedCmd,
                                     {fun reply/3, [WebSocket, ProtocolVersion]}),
            socket_server(WebSocket, ProtocolVersion);
        {tcp_closed, WebSocket} ->
            io:format("Websocket closed. Terminating socket_server...~n");
        {push, [Websocket, ProtocolVersion], Event} ->
            % @todo send stuff to the user
            io:format("socket_server received event:~p~n", [Event]),
            socket_server(WebSocket, ProtocolVersion)
        Any ->
            io:format("socket_server received msg:~p~n", [Any]),
            socket_server(WebSocket, ProtocolVersion)
    end.

%%-------------------------------------------------------------------
%% @doc
%% Callback function that gets called by controller
%% @end
%%-------------------------------------------------------------------
reply([WebSocket, ProtocolVersion], Result, Data) ->
    Reply = get_reply(Result, Data, fe_messages:get(Result, Data)),
    yaws_api:websocket_send(WebSocket, ProtocolVersion, Reply).

%%-------------------------------------------------------------------
%% Compose replies based on data returned from backend
%%-------------------------------------------------------------------
get_reply({Cmd, Status}, Data, Msg) ->
    Event = atom_to_list(Cmd) ++ "_" ++ atom_to_list(Status),
    Reply = get_ret({Cmd, Status}, #ret{event=Event, message_value=Msg}, Data),
    json_encode(ret_to_proplist(Reply));
get_reply(unknown_command, Data, Msg) ->
    io:format("Unknown command~p~n", [Data]),
    json_encode("").


%%-------------------------------------------------------------------
%% Functions that handle return data
%%-------------------------------------------------------------------
%% @doc
%% Format for returning messages to the client
%% Returns the updated ret record
%% @end
%%-------------------------------------------------------------------
%% Update message type to success
msg_success(Ret=#ret{}) ->
    Ret#ret{message_type="success"}.

%% Update message type to error
msg_error(Ret=#ret{}) ->
    Ret#ret{message_type="error"}.

get_ret({register, success}, Ret=#ret{}, _Data) ->
    msg_success(Ret#ret{page="home"});
get_ret({register, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({login, success}, Ret=#ret{}, Session) ->
    Data = [{"session_id", Session}],
    EventData = json2:obj_from_list(Data),
    msg_success(Ret#ret{event_data = EventData,
                        page="dashboard"});
get_ret({login, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({get_session_user, success}, Ret=#ret{}, User) ->
    RequiredFields = ["nick", "email", "name"],
    Data = data_format:userrec_to_proplist(User, {string, RequiredFields}),
    EventData = json2:obj_from_list(Data),
    msg_success(Ret#ret{event_data = EventData,
                        page="dashboard"});
get_ret({get_session_user, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);
get_ret({get_session_user, invalid_session}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({update_user, success}, Ret=#ret{}, User) ->
    RequiredFields = ["nick", "email", "name"],
    Data = data_format:userrec_to_proplist(User, {string, RequiredFields}),
    EventData = json2:obj_from_list(Data),
    msg_success(Ret#ret{event_data = EventData,
                        page="dashboard"});
get_ret({update_user, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({get_game, success}, Ret=#ret{}, Game) ->
    RequiredFields = ["id", "creator_id", "name", "description", "password",
                      "press", "order_phase", "retreat_phase", "build_phase",
                      "waiting_time", "num_players", "result"],
    Data = data_format:gamerec_to_proplist(Game, {string, RequiredFields}),
    EventData = json2:obj_from_list(Data),
    msg_success(Ret#ret{event_data = EventData});
get_ret({get_game, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({reconfig_game, success}, Ret=#ret{}, _Data) ->
    msg_success(Ret#ret{page="dashboard"});
get_ret({reconfig_game, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({create_game, success}, Ret=#ret{}, _Data) ->
    msg_success(Ret#ret{page="dashboard"});
get_ret({create_game, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({join_game, success}, Ret=#ret{}, _Data) ->
    msg_success(Ret#ret{page="dashboard"});
get_ret({join_game, error}, Ret=#ret{}, _Data) ->
    msg_error(Ret#ret{page="dashboard"});
get_ret({join_game, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret#ret{page="dashboard"});

get_ret({game_overview, success}, Ret=#ret{}, GOv) ->
    {GameId, Country, Game, Provinces, Units, Orders} =
        data_format:game_overview_to_text(GOv),
    OrdersString = lists:flatten(io_lib:format("~p", [Orders])),
    Data = [{"game_id", integer_to_list(GameId)},
            {"country", atom_to_list(Country)},
            {"game", lists:flatten(Game)},
            {"provinces", lists:flatten(Provinces)},
            {"units", lists:flatten(Units)},
            {"orders", OrdersString}],
    EventData = json2:obj_from_list(Data),
    msg_success(Ret#ret{event_data = EventData,
                        page="game"});
get_ret({game_overview, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret);

get_ret({game_order, success}, Ret=#ret{}, _Data) ->
    msg_success(Ret);
get_ret({game_order, invalid_data}, Ret=#ret{}, _Data) ->
    msg_error(Ret).


%% Convert data from websocket (JSON) to erlang terms
json_decode(Data) ->
    json2:decode_string(binary_to_list(Data)).

%% Convert erlang terms to JSON
json_encode(Data) ->
    list_to_binary(json2:encode(json2:obj_from_list(Data))).

%% Converts ret record to proplist
ret_to_proplist(Ret) ->
    RecordInfo = [atom_to_list(Field) || Field <- record_info(fields, ret)],
    lists:zip(RecordInfo, tl(tuple_to_list(Ret))).

</erl>
