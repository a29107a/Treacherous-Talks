#!/bin/bash

# erlang's os:cmd does not return the exit code, 
#therefore this is implemented as bash script

cwd=$(pwd)
errors=0

# Setup the shell to report errors even when piping commands. This allows sed
# to operate on output while preserving the exit code from the previous
# command. Warning! This is a bash specific feature.
set -o pipefail

rebar get-deps || errors=1

#################################
## build the global dependencies here (if they require, for instance, make-calls)

# This is a wrapper function that takes one argument, the command to run, and
# executes it. It streams all output through sed to replace warnings so that
# Buildbot won't pick them up. It also indicates if an error occured.
function build_dep () {
    local_error=0
    $1 | sed s/Warning/ignore-warning/ || local_error=1
    case "$local_error" in
        0) echo "##### Exit status: success" ;;
        *) echo "##### Exit status: ERROR" ;;
    esac
    errors=$local_error
}

#PROTOBUFFS
cd deps/protobuffs
build_dep "make all"
cd ../..

# RIAK CLIENT
cd deps/riakc
build_dep "make all"
cd ../..

# YAWS WEB SERVER
echo "##### trying to build yaws"
cd deps/yaws
autoconf || errors=1
./configure --disable-pam || errors=1
build_dep "make"
cd ../..

# xmpp_frontend
echo "##### trying to build xmpp_frontend"
# ejabberd
echo trying to build ejabberd
cd ext_rel/xmpp_frontend
build_dep "make ejabberd-installation"
cd ../..
##
##################################

cd $cwd/apps
for app in $(ls); do
    if [ ! -d $app ]; then
        echo $app is not a dir
        pwd
        continue
    fi

    cd $app
    if [ -x build ]; then
        echo "####################################"
        RACE_COND=".."
        while [ ! -z "$RACE_COND" ]; do
            echo "##### executing " $(pwd)"/build"
            # Run the build file, buffer the output and check the return code
            if OUT=$(./build 2>&1); then
                echo -e "$OUT"
                echo -e "##### Exit status: success\n"
                RACE_COND=""
            else
                echo -e "$OUT"
                echo -e "##### Exit status: ERROR\n"
                # Now we grep for bad rebar builds
                RACE_COND=$(echo $OUT  | grep ".bea#" | grep "no such file or directory")
                # If the grep returned nothing, this was a real error
                if [ -z "$RACE_COND" ]; then
                    errors=1
                fi
            fi
        done
    fi
    cd ..
done
cd $cwd

if (( errors )); then
    echo "##### Build was NOT successfull."
else
    echo "##### Build was successfull."
fi

exit $errors

