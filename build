#!/bin/bash

# erlang's os:cmd does not return the exit code, 
#therefore this is implemented as bash script

cwd=$(pwd)
errors=0

rebar get-deps || errors=1

#################################
## build the global dependencies here (if they require, for instance, make-calls)

#PROTOBUFFS
cd deps/protobuffs
make all || errors=1
cd ../..

# RIAK CLIENT
cd deps/riakc
make all || errors=1
cd ../..

# YAWS WEB SERVER
echo trying to build yaws
cd deps/yaws
autoconf || errors=1
./configure --disable-pam || errors=1
make || errors=1
cd ../..
##
##################################

cd $cwd/apps
for app in $(ls); do
    if [ ! -d $app ]; then
        echo $app is not a dir
        pwd
        continue
    fi

    cd $app
    if [ -x build ]; then
        echo "####################################"
        RACE_COND=".."
        while [ ! -z "$RACE_COND" ]; do
            echo "##### executing " $(pwd)"/build"
            # Run the build file, buffer the output and check the return code
            if OUT=$(./build 2>&1); then
                echo -e "$OUT"
                echo -e "##### Exit status: success\n"
                RACE_COND=""
            else
                echo -e "$OUT"
                echo -e "##### Exit status: ERROR\n"
                # Now we grep for bad rebar builds
                RACE_COND=$(echo $OUT  | grep ".bea#" | grep "no such file or directory")
                # If the grep returned nothing, this was a real error
                if [ -z "$RACE_COND" ]; then
                    errors=1
                fi
            fi
        done
    fi
    cd ..
done
cd $cwd

if (( errors )); then
    echo "##### Build was NOT successfull."
else
    echo "##### Build was successfull."
fi

exit $errors

