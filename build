#!/bin/bash

# erlang's os:cmd does not return the exit code, 
#therefore this is implemented as bash script

cwd=$(pwd)
errors=0
ejdctl=ext_rel/xmpp_frontend/rel/xmpp_frontend/installation/sbin/ejabberdctl

# Set manual build order for apps/ dir (note that anything in that directory not
# mentioned here will still get built; but after the ones defined here).
apps_to_build_first="datatypes service db"

# Setup the shell to report errors even when piping commands. This allows sed
# to operate on output while preserving the exit code from the previous
# command. Warning! This is a bash specific feature.
set -o pipefail

rebar get-deps || errors=1

#################################
## build the global dependencies here (if they require, for instance, make-calls)

# Convenience function for echoing to stderr
function echoerr() { echo -e "$@" 1>&2; }

# This is a wrapper function that takes one argument, the command to run, and
# executes it. It streams all output through sed to replace warnings so that
# Buildbot won't pick them up. It also indicates if an error occured.
function build_dep () {
    local_error=0
    $1 | sed s/Warning/ignore-warning/ || local_error=1
    case "$local_error" in
        0) echo "##### Exit status: success" ;;
        *) echoerr "##### Exit status: ERROR" ;;
    esac
    errors=$local_error
}

# PROTOBUFFS
cd deps/protobuffs
build_dep "make all"
cd $cwd

# RIAK CLIENT
cd deps/riakc
build_dep "make all"
cd $cwd

# YAWS WEB SERVER
echo "##### trying to build yaws"
cd deps/yaws
autoconf || errors=1
./configure --disable-pam || errors=1
build_dep "make -j4"
cd $cwd
##
##################################

cd $cwd/apps
# Get all subdirectories
app_dirs=$(ls)
# Create a variable storing only the directories in $app_dirs that is not in the
# $apps variable (basically the complement in set theory, $app_dirs \ $apps)
rest_of_apps=$(echo -e $app_dirs $apps_to_build_first | sed 's/ /\n/g' \
               | sort | uniq -u)
# Concatenate the two variables to create the correct build order
app_build_order="$apps_to_build_first $rest_of_apps"
# Do actual build loop
for app in ${app_build_order[@]}; do
    if [ ! -d $app ]; then
        echo $app is not a dir
        pwd
        continue
    fi

    cd $app
    if [ -x build ]; then
        echo "####################################"
        race_cond=1
        while [ "$race_cond" -ne 0 ]; do
            echo "##### executing " $(pwd)"/build"
            # Run the build file and pipe all output through a perl one-liner
            # that detects rebar race conditions and returns a special error
            # code in that case.
            ./build 2>&1 | perl -pe 'END { print; exit $status } $status=100 
                                     if /\.bea#.*: no such file or directory/;'
            case $? in
                0)   echo -e "##### Exit status: success\n"
                     race_cond=0;;
                100) echoerr "##### Exit status: ERROR (due to rebar)\n"
                     race_cond=1;;
                *)   echoerr "##### Exit status: ERROR\n"
                     errors=1
                     race_cond=0;;
            esac
        done
    fi
    cd ..
done
cd $cwd



    # XMPP FRONTEND (ejabberd)
    # Ideally build xmpp_frontend after building the rest since
    # so that rebar's intermittent failures don't break the entire
    # build. xmpp_frontend's makefile runs rebar build scripts in
    # without the above loop.
    echo "##### trying to build xmpp_frontend"
    # ejabberd
    echo trying to build ejabberd
    cd ext_rel/xmpp_frontend
    build_dep "make release"
    cd $cwd
    echo
    echo

    # XMPP FRONTEND TESTS
    echo "##### trying to build xmpp_frontend tests (including exmpp)"
    cd ext_test/ejabberd_echo
    build_dep "./build"
    cd $cwd


if (( errors )); then
    echoerr "##### Build was NOT successfull."
else
    echo "##### Build was successfull."
fi

exit $errors

